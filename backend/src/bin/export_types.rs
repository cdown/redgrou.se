//! Generates TypeScript type definitions from Rust structs.
//!
//! Run with: cargo run --bin export_types
//!
//! Output goes to ../frontend/src/lib/generated/

use std::fs;
use std::path::Path;

use redgrouse::filter::{
    Combinator, Condition, FieldMetadata, FilterGroup, FilterValue, Operator, Rule,
};
use redgrouse::sightings::{Sighting, SightingsResponse};
use redgrouse::upload::{DeleteResponse, UpdateResponse, UploadError, UploadResponse};
use ts_rs::TS;

fn main() {
    let out_dir = Path::new("../frontend/src/lib/generated");

    if out_dir.exists() {
        fs::remove_dir_all(out_dir).expect("Failed to clean output directory");
    }
    fs::create_dir_all(out_dir).expect("Failed to create output directory");

    // Export all types
    Combinator::export_all_to(out_dir).expect("Failed to export Combinator");
    Operator::export_all_to(out_dir).expect("Failed to export Operator");
    FilterValue::export_all_to(out_dir).expect("Failed to export FilterValue");
    Condition::export_all_to(out_dir).expect("Failed to export Condition");
    Rule::export_all_to(out_dir).expect("Failed to export Rule");
    FilterGroup::export_all_to(out_dir).expect("Failed to export FilterGroup");
    FieldMetadata::export_all_to(out_dir).expect("Failed to export FieldMetadata");
    Sighting::export_all_to(out_dir).expect("Failed to export Sighting");
    SightingsResponse::export_all_to(out_dir).expect("Failed to export SightingsResponse");
    UploadResponse::export_all_to(out_dir).expect("Failed to export UploadResponse");
    UploadError::export_all_to(out_dir).expect("Failed to export UploadError");
    UpdateResponse::export_all_to(out_dir).expect("Failed to export UpdateResponse");
    DeleteResponse::export_all_to(out_dir).expect("Failed to export DeleteResponse");

    // Generate index.ts by scanning exported files
    let mut type_names: Vec<String> = fs::read_dir(out_dir)
        .expect("Failed to read output directory")
        .filter_map(|entry| {
            let entry = entry.ok()?;
            let path = entry.path();
            let name = path.file_stem()?.to_str()?;
            if path.extension().map_or(false, |ext| ext == "ts") && name != "index" {
                Some(name.to_string())
            } else {
                None
            }
        })
        .collect();

    type_names.sort();

    let mut index_content = String::from(
        "// Auto-generated by backend/src/bin/export_types.rs\n\
         // Do not edit manually - run `cargo run --bin export_types` to regenerate\n\n",
    );
    for name in &type_names {
        index_content.push_str(&format!(
            "export type {{ {} }} from \"./{}\";\n",
            name, name
        ));
    }

    fs::write(out_dir.join("index.ts"), index_content).expect("Failed to write index.ts");

    println!("TypeScript types exported to {:?}", out_dir);
}
